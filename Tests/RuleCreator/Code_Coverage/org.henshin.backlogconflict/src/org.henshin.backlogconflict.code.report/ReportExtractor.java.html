<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="de"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../../jacoco-resources/report.gif" type="image/gif"/><title>ReportExtractor.java</title><link rel="stylesheet" href="../../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../../index.html" class="el_report">JSONTransformerTest (04.07.2024 14:34:06)</a> &gt; <a href="../../index.html" class="el_group">org.henshin.backlogconflict</a> &gt; <a href="../index.html" class="el_bundle">src</a> &gt; <a href="index.source.html" class="el_package">org.henshin.backlogconflict.code.report</a> &gt; <span class="el_source">ReportExtractor.java</span></div><h1>ReportExtractor.java</h1><pre class="source lang-java linenums">package org.henshin.backlogconflict.code.report;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.nio.file.DirectoryStream;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Comparator;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

//import org.eclipse.core.internal.resources.Resource;
import org.eclipse.emf.common.util.URI;
import org.eclipse.emf.ecore.EAttribute;
import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EClassifier;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.emf.ecore.EReference;
import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.emf.ecore.resource.ResourceSet;
import org.eclipse.emf.ecore.resource.impl.ResourceSetImpl;
import org.eclipse.emf.ecore.xmi.impl.XMIResourceFactoryImpl;
import org.henshin.backlogconflict.code.evaluation.Evaluation;
<span class="nc" id="L32">import org.henshin.backlogconflict.code.rule.EmptyOrNotExistJsonFile;</span>
import org.henshin.backlogconflict.code.rule.JsonFileNotFound;
import org.henshin.backlogconflict.code.rule.TextInJsonFileNotFound;
import org.henshin.backlogconflict.code.rule.UsNrInJsonFileNotFound;
import org.json.JSONArray;
import org.json.JSONException;
import org.json.JSONObject;
import org.json.JSONTokener;

import java.util.Set;
import java.util.HashSet;

/** Report maximal overlap if and only if in Minimal Models
 * at least Entity, Action and Triggers exist. With Table summary
 */
/**
 * @author amirr
 *
 */
public class ReportExtractor {
	private static String dirName;
	private static String jsonDatasetFile;

	public ReportExtractor(String directroyName, String jsonFileName) {
		dirName = directroyName;
		jsonDatasetFile = jsonFileName;
	}

<span class="nc" id="L60">	public static void main(String[] args) throws IOException, NullPointerException, EmptyOrNotExistJsonFile,</span>
			CdaReportDirNotFound, JsonFileNotFound, , CdaReportDirIsEmpty {

//		 String[] datasets = { &quot;03&quot;, &quot;04&quot;, &quot;05&quot;, &quot;08&quot;, &quot;10&quot;, &quot;11&quot;, &quot;12&quot;, &quot;14&quot;, &quot;16&quot;,
//		 &quot;21&quot;, &quot;22&quot;, &quot;23&quot;, &quot;24&quot;,
//		 &quot;25&quot;, &quot;26&quot;, &quot;27&quot;, &quot;28&quot; };
		String[] datasets = { &quot;04&quot;,&quot;11&quot;,&quot;10&quot;,&quot;27&quot;,&quot;19&quot; };
		reportExtractor(datasets);
	}
<span class="nc" id="L69">	public static void reportExtractor(String[] datasets) throws IOException, NullPointerException, EmptyOrNotExistJsonFile, CdaReportDirNotFound, JsonFileNotFound, CdaReportDirIsNotADirectory, CdaReportDirIsEmpty {</span>
		Path path = Paths.get(&quot;C:\\Users\\amirr\\eclipse-workspace_new\\org.henshin.backlog2\\Final_Reports\\&quot;);
		// checked: 21, 04,03 ,05,08,10,11,12,14,16
//		 Version of data set &quot;18&quot;, &quot;19&quot;
		for (int i = 0; i &lt; datasets.length; i++) {
			System.out.println(&quot;Dataset: &quot; + datasets[i]);
			long startTime = System.nanoTime();
			ReportExtractor cdaConvertor = new ReportExtractor(
					&quot;eclipse-workspace_2023_12\\CDA_Reports\\CDA_Report_backlog_g&quot; + datasets[i],
					&quot;Final_Reports\\Textual_Report_g&quot; + datasets[i] + &quot;\\g&quot; + datasets[i] + &quot;_baseline_pos.json&quot;);

			// Create text file in order to report to user a readable format
			File cdaReport = new File(cdaConvertor.getFinalReportDir(path) + &quot;\\Textual_Report_g&quot; + datasets[i]
					+ &quot;\\Textual_Report_g&quot; + datasets[i] + &quot;.txt&quot;);
			FileWriter fileWriter = cdaConvertor.createOrOverwriteReportFile(cdaReport);

			// Create JSON File in order to have systematic overview of result
			File jsonReport = new File(cdaConvertor.getFinalReportDir(path) + &quot;\\Textual_Report_g&quot; + datasets[i]
					+ &quot;\\JSON_Report_g&quot; + datasets[i] + &quot;.json&quot;);
			FileWriter jsonWriter = cdaConvertor.createOrOverwriteReportFile(jsonReport);
			List&lt;ConflictPair&gt; listConflictPairs = cdaConvertor.extractReports(fileWriter, jsonWriter);
			cdaConvertor.writeTable(cdaReport, listConflictPairs);
			long endTime = System.nanoTime();
			double elapsedTimeInSeconds= (endTime-startTime)/ 1_000_000_000.0;
	        System.out.println(&quot;Processing time: &quot; + elapsedTimeInSeconds + &quot; seconds&quot;);

		}
		
	}

<span class="nc" id="L99">	public String getDirName() {</span>
		return dirName;
	}

<span class="nc" id="L103">	public String getJsonDatasetFile() {</span>
		return jsonDatasetFile;
	}

	public String getAbsoluteDirPath()
<span class="nc" id="L108">			throws CdaReportDirNotFound, CdaReportDirIsNotADirectory, CdaReportDirIsEmpty, IOException {</span>
		Path path = Paths.get(&quot;C:\\Users\\amirr\\&quot; + getDirName());
		if (Files.exists(path)) {
			if (Files.isDirectory(path)) { // Check if it's a directory
				DirectoryStream&lt;Path&gt; directoryStream = Files.newDirectoryStream(path);
				boolean isEmpty = true;
				boolean hasSubDirectories = false;

				for (Path entry : directoryStream) {
					if (Files.isDirectory(entry)) {
						hasSubDirectories = true;
					}
					isEmpty = false;
				}

				// if (isEmpty) {
				// throw new CdaReportDirIsEmpty(&quot;CDA Report Directory is empty!&quot;);
				// }

				if (!hasSubDirectories) {
					throw new CdaReportDirIsEmpty(&quot;CDA Report Directory found but doesn't have any subdirectories!&quot;);
				} else {
					return path.toString();
				}

			} else {
				throw new CdaReportDirIsNotADirectory();
			}
		} else {
			throw new CdaReportDirNotFound();
		}
	}

<span class="nc" id="L141">	public String getAbsoluteFinalReportDir() throws JsonFileNotFound {</span>
		Path path = Paths.get(&quot;C:\\Users\\amirr\\eclipse-workspace_new\\org.henshin.backlog2\\&quot; + getJsonDatasetFile());
		if (Files.exists(path)) {

			return path.toString();
		} else {
			throw new JsonFileNotFound();
		}
	}

<span class="nc" id="L151">	public String getFinalReportDir(Path path) {</span>

		if (Files.exists(path)) {

			System.out.println(path.toString());
			return path.toString();
		} else {
			return null;
		}
	}

	// Create or overwrite report file which return/pass the FileWriter object
<span class="nc" id="L163">	public FileWriter createOrOverwriteReportFile(File totalCda) throws IOException {</span>
		FileWriter cdaWriter = null;
		if (totalCda.createNewFile()) {
			// System.out.println(&quot;File created succesfully: &quot; + totalCda.getName());
			cdaWriter = new FileWriter(totalCda);
			return cdaWriter;

		} else {
			cdaWriter = new FileWriter(totalCda);
			// System.out.println(&quot;File already exists. Try to overwrite..!&quot;);
			return cdaWriter;
		}
	}

	public List&lt;ConflictPair&gt; extractReports(FileWriter fileWriter, FileWriter jsonWriter)
<span class="nc" id="L178">			throws IOException, NullPointerException, EmptyOrNotExistJsonFile, CdaReportDirNotFound, JsonFileNotFound,</span>
			CdaReportDirIsNotADirectory, CdaReportDirIsEmpty {

		// create JSON array in order to contains all redundant pairs and their
		JSONArray jsonArray = new JSONArray();

		ConflictItems redundancyItems;
		List&lt;ConflictPair&gt; redundantPairs;
		ArrayList&lt;String&gt; arrayTotalElements;
		ArrayList&lt;String&gt; arrayTotalElementsNames;
		List&lt;String&gt; pairList = new ArrayList&lt;&gt;();
		File main = new File(getAbsoluteDirPath());
		// Instantiate redundantPairs
		redundantPairs = new ArrayList&lt;&gt;();
		// Iterate through critical pairs
		if (main.exists() &amp;&amp; main.list().length != 0) {
			for (String redPair : main.list()) {
				if (!checkIfReportExist(redPair, pairList) &amp;&amp; containsAnd(redPair)) {
					File conflictReasonDir = new File(getAbsoluteDirPath() + &quot;\\&quot; + redPair);
					if (!conflictReasonDir.isFile()) {
						JSONObject jsonRedundancyPair = new JSONObject();
						arrayTotalElementsNames = new ArrayList&lt;&gt;();
						arrayTotalElements = new ArrayList&lt;&gt;();
						redundancyItems = new ConflictItems();
						String[] conflictReasonListing = conflictReasonDir.list();
						// Iterate through conflict reasons if there is more than one conflict_reason.
						if (conflictReasonListing.length &gt; 1) {
							for (String conflictReason : conflictReasonListing) {
								// Check if minimal ECore exist
								if (minimalEcoreExist(redPair, conflictReason)) {
									File minimalModelEcoreFile = new File(getAbsoluteDirPath() + &quot;\\&quot; + redPair + &quot;\\&quot;
											+ conflictReason + &quot;\\minimal-model.ecore&quot;);

									processMinimalModels(minimalModelEcoreFile, arrayTotalElements,
											arrayTotalElementsNames, redundancyItems);

								}
							}
						}
						// Write only the Elements which contains Primary/Secondary Action and
						// Primary/Secondary Entity
						if (hasEntitys(arrayTotalElementsNames, redundancyItems)
								&amp;&amp; hasActions(arrayTotalElementsNames, redundancyItems)
								&amp;&amp; hasTargets(arrayTotalElementsNames, redundancyItems)) {
							fileWriter.write(&quot;\n------------------[Potential Redundant User&quot;
									+ &quot; Stories found]--------------------------\n{&quot; + redPair + &quot;}\n  &quot;);
							jsonRedundancyPair.put(&quot;Potential Redundant User Stories&quot;, redPair);

							fileWriter.write(&quot;\nRedundant clauses within user stories are: &quot;);
							List&lt;TargetsPair&gt; targetsPairs = getCommonTargets(redPair, jsonRedundancyPair);
							List&lt;ContainsPair&gt; containsPairs = getCommonContains(redPair, jsonRedundancyPair);
							List&lt;TriggersPair&gt; triggersPairs = getCommonTriggers(redPair);
							redundancyItems.printRedundantItems(fileWriter, targetsPairs, containsPairs, triggersPairs,
									jsonRedundancyPair);

							// receive text of user stories as input
							// in order to highlight the redundancy clauses in each text
							writeUsText(redPair, arrayTotalElementsNames, redundantPairs, redundancyItems, fileWriter,
									targetsPairs, triggersPairs, containsPairs, jsonRedundancyPair);

							// add JSON Object into main JSON array
							JSONObject jsonConflictStatus = getRedundancyStatus(redundancyItems);

							// put all in Status as subPart of &quot;Status&quot;
							jsonRedundancyPair.put(&quot;Status&quot;, jsonConflictStatus);

							if (redundancyItems.getTextUs1() != null &amp;&amp; redundancyItems.getTextUs2() != null) {
								fileWriter.write(&quot;\n\nThe following sentence parts are&quot; + &quot; candidates for possible&quot;
										+ &quot; redundancies between user stories:\n\n&quot;);

								// here we should write USsSentenceParts
								writeUsSentencePart(redPair, redundancyItems, fileWriter, jsonRedundancyPair);

								// Try to evaluate, if main or benefit part are fully/partially redundant
								String us1 = getUsName1(redPair);
								String us2 = getUsName2(redPair);
								Evaluation evaluation = new Evaluation();
								evaluation.evaluateRedundancyCriteria(jsonRedundancyPair, us1, us2);
								// Add JSONObject Texts of two user story and store them into Text JSONObject
								JSONObject jsonText = new JSONObject();
								jsonText.put(&quot;First UserStory&quot;,
										getUsName1(redPair) + &quot;: &quot; + redundancyItems.getTextUs1());
								jsonText.put(&quot;Second UserStory&quot;,
										getUsName2(redPair) + &quot;: &quot; + redundancyItems.getTextUs2());
								jsonRedundancyPair.put(&quot;Text&quot;, jsonText);

								// select project Number and save it to JSONFile
								String projectNr = redundancyItems.getTextUs1().replaceAll(&quot;.*#(g\\d\\d)#.*&quot;, &quot;$1&quot;);
								jsonRedundancyPair.put(&quot;Project Number&quot;, projectNr);
							}

							// add JSON Object into main JSON array
							jsonArray.put(jsonRedundancyPair);

						}

					}
				}
			}

			if (redundantPairs.size() == 0) {
				fileWriter.write(&quot;No redundancy found between user stories!&quot;);

			}
			jsonWriter.write(jsonArray.toString(4));
			jsonWriter.close();
			fileWriter.close();

		}
		return redundantPairs;
	}

	// Add Status Elements(Main/Benefit/Total Part Conflicted Elements) into JSON
	// data
	private JSONObject getRedundancyStatus(ConflictItems redundancyItems) {
		JSONObject jsonRedundancyStatus = new JSONObject();

		// add observed conflicted pairs in Main part sentence
<span class="nc" id="L296">		jsonRedundancyStatus.put(&quot;Main Part Redundancy Clauses&quot;, redundancyItems.getMainRedundancyCount());</span>

		// add observed conflicted pairs in Benefit part sentence
		jsonRedundancyStatus.put(&quot;Benefit Part Redundancy Clause&quot;, redundancyItems.getBenefitRedundancyCount());

		// add observed total conflicted pairs
		jsonRedundancyStatus.put(&quot;Total Redundancy Clauses&quot;, redundancyItems.getTotalRedundancyCount());
		return jsonRedundancyStatus;
	}

	// receive a conflict Pair and a String which corresponds to &quot;Targets&quot; array
	// Object in JSON file
	private List&lt;TargetsPair&gt; getCommonTargets(String redPair, JSONObject jsonRedundancyPair)
<span class="nc" id="L309">			throws EmptyOrNotExistJsonFile, JsonFileNotFound, IOException {</span>
		String us1 = getUsName1(redPair);
		String us2 = getUsName2(redPair);
		List&lt;TargetsPair&gt; targetPairs = new ArrayList&lt;&gt;();
		JSONArray us1TargetsArray = null;
		JSONArray us2TargetsArray = null;
		JSONArray jsonTargetsMainUs1 = new JSONArray();
		JSONArray jsonTargetsBenefitUs1 = new JSONArray();
		JSONArray jsonTargetsMainUs2 = new JSONArray();
		JSONArray jsonTargetsBenefitUs2 = new JSONArray();
		String us1Text = null;
		String us2Text = null;
		JSONArray jsonArray = readJsonArrayFromFile(getAbsoluteFinalReportDir());

		// Check if there US_Nr and Targets Objects exists in JOSN file
		// if so return the ArrayObjects of Targets
		for (int i = 0; i &lt; jsonArray.length(); i++) {
			JSONObject jsonObject = jsonArray.getJSONObject(i);
			if (jsonObject.has(&quot;US_Nr&quot;) &amp;&amp; jsonObject.has(&quot;Targets&quot;)) {
				String usNr = jsonObject.getString(&quot;US_Nr&quot;);
				if (usNr.equals(us1)) {
					us1TargetsArray = jsonObject.getJSONArray(&quot;Targets&quot;);
					us1Text = jsonObject.getString(&quot;Text&quot;).toLowerCase();

				} else if (usNr.equals(us2)) {
					us2TargetsArray = jsonObject.getJSONArray(&quot;Targets&quot;);
					us2Text = jsonObject.getString(&quot;Text&quot;).toLowerCase();

				}
			}
		}
		// check if TargetArrays of both USs not null then find the Common
		// Targets Pairs and add it to TargetPairs List
		if (us2TargetsArray != null &amp;&amp; us1TargetsArray != null) {
			for (int i = 0; i &lt; us1TargetsArray.length(); i++) {
				JSONArray jsonArrayUs1 = us1TargetsArray.getJSONArray(i);
				String actionUs1 = jsonArrayUs1.getString(0).toLowerCase();
				String entityUs1 = jsonArrayUs1.getString(1).toLowerCase();
				JSONArray mainTargetsUs1 = new JSONArray();
				mainTargetsUs1 = getAllTargetsInMain(actionUs1, entityUs1, us1Text, jsonRedundancyPair);
				if (mainTargetsUs1 != null) {
					jsonTargetsMainUs1.put(mainTargetsUs1);
				}
				JSONArray benefitTargetsUs1 = new JSONArray();
				benefitTargetsUs1 = getAllTargetsInBenefit(actionUs1, entityUs1, us1Text, jsonRedundancyPair);
				if (benefitTargetsUs1 != null) {
					jsonTargetsBenefitUs1.put(benefitTargetsUs1);
				}
				for (int j = 0; j &lt; us2TargetsArray.length(); j++) {
					JSONArray jsonArrayUs2 = us2TargetsArray.getJSONArray(j);
					String actionUs2 = jsonArrayUs2.getString(0).toLowerCase();
					String enttiyUs2 = jsonArrayUs2.getString(1).toLowerCase();
					if (enttiyUs2.equalsIgnoreCase(entityUs1) &amp;&amp; actionUs2.equalsIgnoreCase(actionUs1.toLowerCase())) {
						targetPairs.add(new TargetsPair(actionUs1, entityUs1));
						break;
					}
				}
			}
			// iterate through other US and gather all Targets in there
			for (int j = 0; j &lt; us2TargetsArray.length(); j++) {
				JSONArray jsonArrayUs2 = us2TargetsArray.getJSONArray(j);
				String actionUs2 = jsonArrayUs2.getString(0).toLowerCase();
				String enttiyUs2 = jsonArrayUs2.getString(1).toLowerCase();
				JSONArray mainTargetsUs2 = new JSONArray();
				mainTargetsUs2 = getAllTargetsInMain(actionUs2, enttiyUs2, us2Text, jsonRedundancyPair);
				if (mainTargetsUs2 != null) {
					jsonTargetsMainUs2.put(mainTargetsUs2);
				}

				JSONArray benefitTargetsUs2 = new JSONArray();
				benefitTargetsUs2 = getAllTargetsInBenefit(actionUs2, enttiyUs2, us2Text, jsonRedundancyPair);
				if (benefitTargetsUs2 != null) {
					jsonTargetsBenefitUs2.put(benefitTargetsUs2);
				}
			}

		}
		JSONObject jsonAllTargets = new JSONObject();

		JSONObject jsonObjectAllTargetsUS1 = new JSONObject();
		JSONObject jsonObjectAllTargetsUS2 = new JSONObject();

		JSONObject jsonAllTargetsUS2Main = new JSONObject();
		JSONObject jsonAllTargetsUS2Benefit = new JSONObject();

		jsonObjectAllTargetsUS1.put(&quot;Main Part&quot;, jsonTargetsMainUs1);
		jsonObjectAllTargetsUS1.put(&quot;Benefit Part&quot;, jsonTargetsBenefitUs1);

		jsonAllTargetsUS2Main.put(&quot;Main Part&quot;, jsonTargetsMainUs2);
		jsonAllTargetsUS2Benefit.put(&quot;Benefit Part&quot;, jsonTargetsBenefitUs2);

		jsonObjectAllTargetsUS2.put(&quot;Main Part&quot;, jsonTargetsMainUs2);
		jsonObjectAllTargetsUS2.put(&quot;Benefit Part&quot;, jsonTargetsBenefitUs2);

		jsonAllTargets.put(us1, jsonObjectAllTargetsUS1);
		jsonAllTargets.put(us2, jsonObjectAllTargetsUS2);
		jsonRedundancyPair.put(&quot;All Targets&quot;, jsonAllTargets);

		return targetPairs;
	}

<span class="nc" id="L410">	private JSONArray getAllTargetsInBenefit(String action, String entity, String usText,</span>
			JSONObject jsonRedundancyPair) {
		int benefitIndex = usText.indexOf(&quot;so that&quot;);
		JSONArray jsonBenefit = new JSONArray();
		String benefitPart = &quot;&quot;;
		if (benefitIndex != -1) {
			benefitPart = usText.substring(benefitIndex);
			jsonBenefit = processElements(action, entity, benefitPart, jsonRedundancyPair);
			return jsonBenefit;
		}

		return null;

	}

<span class="nc" id="L425">	private JSONArray getAllTargetsInMain(String action, String entity, String usText, JSONObject jsonRedundancyPair) {</span>
		int benefitIndex = usText.indexOf(&quot;so that&quot;);
		String mainPart = usText;
		JSONArray jsonMain = new JSONArray();
		if (benefitIndex != -1) {

			mainPart = usText.substring(0, benefitIndex);
		}
		jsonMain = processElements(action, entity, mainPart, jsonRedundancyPair);
		return jsonMain;

	}

	// receive a conflict Pair and a String which corresponds to &quot;Triggers&quot; array
	// Object in JSON file
	private List&lt;TriggersPair&gt; getCommonTriggers(String redPair)
<span class="nc" id="L441">			throws EmptyOrNotExistJsonFile, JsonFileNotFound, IOException {</span>
		String us1 = getUsName1(redPair);
		String us2 = getUsName2(redPair);
		List&lt;TriggersPair&gt; triggersPairs = new ArrayList&lt;&gt;();

		JSONArray us1TriggersArray = null;
		JSONArray us2TriggersArray = null;
		JSONArray jsonArray = readJsonArrayFromFile(getAbsoluteFinalReportDir());

		for (int i = 0; i &lt; jsonArray.length(); i++) {
			JSONObject jsonObject = jsonArray.getJSONObject(i);
			if (jsonObject.has(&quot;US_Nr&quot;) &amp;&amp; jsonObject.has(&quot;Triggers&quot;)) {
				String usNr = jsonObject.getString(&quot;US_Nr&quot;);
				if (usNr.equals(us1)) {
					us1TriggersArray = jsonObject.getJSONArray(&quot;Triggers&quot;);

				} else if (usNr.equals(us2)) {
					us2TriggersArray = jsonObject.getJSONArray(&quot;Triggers&quot;);

				}
			}
		}
		if (us2TriggersArray != null &amp;&amp; us1TriggersArray != null) {
			// first check if entity in Triggers is also exist in common Targets

			for (int i = 0; i &lt; us1TriggersArray.length(); i++) {
				JSONArray jsonArrayUs1 = us1TriggersArray.getJSONArray(i);
				String personaUs1 = jsonArrayUs1.getString(0).toLowerCase();
				String actionUs1 = jsonArrayUs1.getString(1).toLowerCase();
				for (int j = 0; j &lt; us2TriggersArray.length(); j++) {
					JSONArray jsonArrayUs2 = us2TriggersArray.getJSONArray(j);
					String personaUs2 = jsonArrayUs2.getString(0).toLowerCase();
					String actionUs2 = jsonArrayUs2.getString(1).toLowerCase();
					// check if both action and persona in triggers from USs
					// are the same
					if (actionUs2.equalsIgnoreCase(actionUs1) &amp;&amp; personaUs2.equalsIgnoreCase(personaUs1)) {
						triggersPairs.add(new TriggersPair(personaUs1, actionUs1));
						break;
						// }
//						}
					}
				}
			}

		}
		return triggersPairs;
	}

	// receive a conflict Pair and a String which corresponds to &quot;Contains&quot; array
	// Object in JSON file
	private List&lt;ContainsPair&gt; getCommonContains(String redPair, JSONObject jsonRedundancyPair)
<span class="nc" id="L492">			throws EmptyOrNotExistJsonFile, JsonFileNotFound, IOException {</span>
		String us1 = getUsName1(redPair);
		String us2 = getUsName2(redPair);
		List&lt;ContainsPair&gt; containsPairs = new ArrayList&lt;&gt;();
		JSONArray us1ContainsArray = null;
		JSONArray us2ContainsArray = null;
		JSONArray jsonContainsMainUs1 = new JSONArray();
		JSONArray jsonContainsBenefitUs1 = new JSONArray();
		JSONArray jsonContainsMainUs2 = new JSONArray();
		JSONArray jsonContainsBenefitUs2 = new JSONArray();
		String us1Text = null;
		String us2Text = null;
		JSONArray jsonArray = readJsonArrayFromFile(getAbsoluteFinalReportDir());

		for (int i = 0; i &lt; jsonArray.length(); i++) {
			JSONObject jsonObject = jsonArray.getJSONObject(i);
			if (jsonObject.has(&quot;US_Nr&quot;) &amp;&amp; jsonObject.has(&quot;Contains&quot;)) {
				String usNr = jsonObject.getString(&quot;US_Nr&quot;);
				if (usNr.equals(us1)) {
					us1ContainsArray = jsonObject.getJSONArray(&quot;Contains&quot;);
					us1Text = jsonObject.getString(&quot;Text&quot;).toLowerCase();

				} else if (usNr.equals(us2)) {
					us2ContainsArray = jsonObject.getJSONArray(&quot;Contains&quot;);
					us2Text = jsonObject.getString(&quot;Text&quot;).toLowerCase();
				}
			}
		}
		if (us2ContainsArray != null &amp;&amp; us1ContainsArray != null) {
			for (int i = 0; i &lt; us1ContainsArray.length(); i++) {
				JSONArray jsonArrayUs1 = us1ContainsArray.getJSONArray(i);
				String parentUs1 = jsonArrayUs1.getString(0).toLowerCase();
				String childUs1 = jsonArrayUs1.getString(1).toLowerCase();
				// add each founded element into JSON report according
				// to their occurrence into main or benefit part
				JSONArray mainContainsUs1 = new JSONArray();
				mainContainsUs1 = getAllContainsInMain(parentUs1, childUs1, us1Text, jsonRedundancyPair);
				if (mainContainsUs1 != null) {
					jsonContainsMainUs1.put(mainContainsUs1);
				}
				JSONArray benefitContainsUs1 = new JSONArray();
				benefitContainsUs1 = getAllContainsInBenefit(parentUs1, childUs1, us1Text, jsonRedundancyPair);
				if (benefitContainsUs1 != null) {
					jsonContainsBenefitUs1.put(benefitContainsUs1);
				}
				for (int j = 0; j &lt; us2ContainsArray.length(); j++) {
					JSONArray jsonArrayUs2 = us2ContainsArray.getJSONArray(j);
					String parentUs2 = jsonArrayUs2.getString(0).toLowerCase();
					String childUs2 = jsonArrayUs2.getString(1).toLowerCase();
					if (childUs2.equalsIgnoreCase(childUs1) &amp;&amp; parentUs2.equalsIgnoreCase(parentUs1.toLowerCase())) {
						containsPairs.add(new ContainsPair(parentUs1, childUs1));
					}
				}
			}
			// iterate through other US and gather all contains in there
			for (int j = 0; j &lt; us2ContainsArray.length(); j++) {
				JSONArray jsonArrayUs2 = us2ContainsArray.getJSONArray(j);
				String parentUs2 = jsonArrayUs2.getString(0).toLowerCase();
				String childUs2 = jsonArrayUs2.getString(1).toLowerCase();
				JSONArray mainContainsUs2 = new JSONArray();
				mainContainsUs2 = getAllContainsInMain(parentUs2, childUs2, us2Text, jsonRedundancyPair);
				if (mainContainsUs2 != null) {
					jsonContainsMainUs2.put(mainContainsUs2);
				}

				JSONArray benefitContainsUs2 = new JSONArray();
				benefitContainsUs2 = getAllContainsInBenefit(parentUs2, childUs2, us2Text, jsonRedundancyPair);
				if (benefitContainsUs2 != null) {
					jsonContainsBenefitUs2.put(benefitContainsUs2);
				}
			}

		}

		JSONObject jsonAllContains = new JSONObject();

		JSONObject jsonObjectAllContainsUS1 = new JSONObject();
		JSONObject jsonObjectAllContainsUS2 = new JSONObject();

		JSONObject jsonAllContainsUS2Main = new JSONObject();
		JSONObject jsonAllContainsUS2Benefit = new JSONObject();

		jsonObjectAllContainsUS1.put(&quot;Main Part&quot;, jsonContainsMainUs1);
		jsonObjectAllContainsUS1.put(&quot;Benefit Part&quot;, jsonContainsBenefitUs1);

		jsonAllContainsUS2Main.put(&quot;Main Part&quot;, jsonContainsMainUs2);
		jsonAllContainsUS2Benefit.put(&quot;Benefit Part&quot;, jsonContainsBenefitUs2);

		jsonObjectAllContainsUS2.put(&quot;Main Part&quot;, jsonContainsMainUs2);
		jsonObjectAllContainsUS2.put(&quot;Benefit Part&quot;, jsonContainsBenefitUs2);

		jsonAllContains.put(us1, jsonObjectAllContainsUS1);
		jsonAllContains.put(us2, jsonObjectAllContainsUS2);
		jsonRedundancyPair.put(&quot;All Contains&quot;, jsonAllContains);

		return containsPairs;
	}

<span class="nc" id="L590">	private JSONArray getAllContainsInBenefit(String parentUs, String childUs, String usText,</span>
			JSONObject jsonRedundancyPair) {
		int benefitIndex = usText.indexOf(&quot;so that&quot;);
		JSONArray jsonBenefit = new JSONArray();
		String benefitPart = &quot;&quot;;
		if (benefitIndex != -1) {
			benefitPart = usText.substring(benefitIndex);
			jsonBenefit = processElements(parentUs, childUs, benefitPart, jsonRedundancyPair);
			return jsonBenefit;
		}

		return null;

	}

<span class="nc" id="L605">	private JSONArray getAllContainsInMain(String parentUs, String childUs, String usText,</span>
			JSONObject jsonRedundancyPair) {
		int benefitIndex = usText.indexOf(&quot;so that&quot;);
		String mainPart = usText;
		JSONArray jsonMain = new JSONArray();
		if (benefitIndex != -1) {
			mainPart = usText.substring(0, benefitIndex);
		}
		jsonMain = processElements(parentUs, childUs, mainPart, jsonRedundancyPair);
		return jsonMain;

	}

<span class="nc" id="L618">	private JSONArray processElements(String parentUs, String childUs, String UsPart, JSONObject jsonRedundancyPair) {</span>
		if (UsPart.contains(parentUs) &amp;&amp; UsPart.contains(childUs)) {
			JSONArray contain = new JSONArray().put(parentUs).put(childUs);
			return contain;
		}
		return null;
	}

	public boolean minimalEcoreExist(String redPair, String conflictReason)
<span class="nc" id="L627">			throws CdaReportDirNotFound, CdaReportDirIsNotADirectory, CdaReportDirIsEmpty, IOException {</span>
		Path path = Paths.get(getAbsoluteDirPath() + &quot;\\&quot; + redPair + &quot;\\&quot; + conflictReason + &quot;\\minimal-model.ecore&quot;);
		if (Files.exists(path)) {
			return true;
		} else {
			return false;
		}

	}

//	This method make sure that folder name is identified
//	with \textit{\_AND\_} due to the fact that through CDA 
//	generated report is formatted like \enquote{user\_story\_\textless 
//		digit \textgreater\_AND\_user\_story\_\textless
<span class="nc" id="L641">	private boolean containsAnd(String folder) {</span>
		if (folder.toLowerCase().contains(&quot;and&quot;)) {
			return true;
		} else {
			return false;
		}
	}

<span class="nc" id="L649">	private void processMinimalModels(File minimalModelEcoreFile, ArrayList&lt;String&gt; arrayMaximalElements,</span>
			ArrayList&lt;String&gt; arrayMaximalElementsNames, ConflictItems redundancyItems) throws IOException {
		if (minimalModelEcoreFile.exists() &amp;&amp; minimalModelEcoreFile.length() &gt; 0) {
			Resource.Factory.Registry resourceFactoryRegistry = Resource.Factory.Registry.INSTANCE;
			resourceFactoryRegistry.getExtensionToFactoryMap().put(&quot;ecore&quot;, new XMIResourceFactoryImpl());
			ResourceSet resourceSet = new ResourceSetImpl();
			Resource resource = resourceSet.getResource(URI.createFileURI(minimalModelEcoreFile.getAbsolutePath()),
					true);
			if (resource != null &amp;&amp; !resource.getContents().isEmpty()) {

				for (EObject eObject : resource.getContents()) {
					EPackage minimalPackage = (EPackage) eObject;

					iteratePackages(minimalPackage, arrayMaximalElements, arrayMaximalElementsNames, redundancyItems);

				}
			}
		}
	}

<span class="nc" id="L669">	private String getUsName1(String us) {</span>
		return us.replaceAll(&quot;(.*)_AND.*&quot;, &quot;$1&quot;);
	}

<span class="nc" id="L673">	private String getUsName2(String us) {</span>
		return us.replaceAll(&quot;.*_AND_(.*)&quot;, &quot;$1&quot;);
	}

	// Receive user stories texts with highlighted elements and
	// return only the part/region of sentences which highlighted elements is
	// appears
<span class="nc" id="L680">	private void writeUsSentencePart(String string, ConflictItems redundancyItems, FileWriter fileWriter,</span>
			JSONObject jsonObject) throws IOException {
		String usNum1 = getUsName1(string);
		String usNum2 = getUsName2(string);
		String usText1 = redundancyItems.getTextUs1();
		String usText2 = redundancyItems.getTextUs2();
		splitUsText(usText1, usNum1, usText2, usNum2, fileWriter, jsonObject);

	}

<span class="nc" id="L690">	private void splitUsText(String usText1, String usNum1, String usText2, String usNum2, FileWriter fileWriter,</span>
			JSONObject jsonObject) throws IOException {
		String[] parts1 = usText1.split(&quot;,&quot;, 3);
		String[] parts2 = usText2.split(&quot;,&quot;, 3);
		// show only part of sentences which include more that two hash symbol pairs
		String regex = &quot;#[^#]+#&quot;;
		Set&lt;String&gt; writtenUserStoryPart1 = new HashSet&lt;&gt;();
		Set&lt;String&gt; writtenUserStoryPart2 = new HashSet&lt;&gt;();
		Pattern pattern = Pattern.compile(regex);
		// Initialize JOSN Object as Parts of Sentence
		JSONObject jsonPartOfSentence = new JSONObject();

		// Create separate user story section part
		for (String part : parts1) {
			Matcher matcher = pattern.matcher(part);
			int count = 0;
			while (matcher.find()) {
				count++;
				if (count &gt;= 2 &amp;&amp; !writtenUserStoryPart1.contains(part)) {
					fileWriter.write(usNum1 + &quot;: &quot; + part + &quot;\n&quot;);
					// Write sentence Part first user story on sentence part A
					jsonPartOfSentence.put(&quot;First UserStory&quot;, new JSONArray().put(part));
					writtenUserStoryPart1.add(part);
				}
			}
		}

		// Create separate user story section part
		for (String part : parts2) {
			Matcher matcher = pattern.matcher(part);
			int count = 0;
			while (matcher.find()) {
				count++;
				if (count &gt;= 2 &amp;&amp; !writtenUserStoryPart2.contains(part)) {
					fileWriter.write(usNum2 + &quot;: &quot; + part + &quot;\n&quot;);
					// Write sentence Part first user story on sentence part A
					jsonPartOfSentence.put(&quot;Second UserStory&quot;, new JSONArray().put(part));
					writtenUserStoryPart2.add(part);
				}
			}
		}
		jsonObject.put(&quot;Part of Sentence&quot;, jsonPartOfSentence);

	}

<span class="nc" id="L735">	public JSONArray readJsonArrayFromFile(String path) throws EmptyOrNotExistJsonFile, JsonFileNotFound, IOException {</span>
		JSONArray jsonArray;
		FileReader reader = new FileReader(path);
		JSONTokener tokener = new JSONTokener(reader);
		if (!tokener.more()) {
			throw new EmptyOrNotExistJsonFile();

		}
		// Read JSON file
		jsonArray = new JSONArray(tokener);

		return jsonArray;

	}

	// in order to insert the table at the very first place of the file
	// we need to first store the report at StringBuilder and then make
	// file again but at this time writing the table first
	public void writeTable(File totalCda, List&lt;ConflictPair&gt; redundantPairs) throws IOException {

		List&lt;String&gt; pairListSeperate = new ArrayList&lt;&gt;();
		StringBuilder report = new StringBuilder();
		BufferedReader reader = new BufferedReader(new FileReader(totalCda));
		String line;
		while ((line = reader.readLine()) != null) {
			report.append(line).append(&quot;\n&quot;);
		}
		reader.close();
		FileWriter writer = new FileWriter(totalCda);

		// display the table
		StringBuilder table = new StringBuilder();
		// add new line before the table
		table.append(&quot;* Table of potential redundancies between user stories&quot;
				+ &quot; and the number of their overlapping elements\n\n&quot;);
		// table.append(&quot;\t&quot;);
		for (ConflictPair redundantPair : redundantPairs) {
<span class="nc" id="L772">			if (!pairListSeperate.contains(redundantPair.getRedundantPair1())) {</span>
				pairListSeperate.add(redundantPair.getRedundantPair1());
			}
			if (!pairListSeperate.contains(redundantPair.getRedundantPair2())) {
				pairListSeperate.add(redundantPair.getRedundantPair2());
			}
		}
		String[][] stringTable = createTable(pairListSeperate, redundantPairs);
		int numCols = stringTable[0].length;

		// find the maximum width for each column
		int[] maxWidths = new int[numCols];
		for (String[] row : stringTable) {
			for (int j = 0; j &lt; numCols; j++) {
				maxWidths[j] = Math.max(maxWidths[j], row[j].length());
			}
		}
		for (String[] row : stringTable) {
			for (int j = 0; j &lt; numCols; j++) {

				table.append(String.format(&quot;%-&quot; + (maxWidths[j] + 2) + &quot;s&quot;, row[j]));
			}
			table.append(&quot;\n&quot;);
		}
		writer.write(table.toString());
		writer.write(report.toString());
		writer.close();

	}

<span class="nc" id="L802">	private String[][] createTable(List&lt;String&gt; pairListSeperate2, List&lt;ConflictPair&gt; redundantPairs2) {</span>
		int size = pairListSeperate2.size();
		String[][] table = new String[size + 1][size + 1];

		table[0][0] = &quot;&quot;;
		for (int i = 0; i &lt; size; i++) {
			table[0][i + 1] = pairListSeperate2.get(i).replaceAll(&quot;user_story&quot;, &quot;us&quot;); // header row
			table[i + 1][0] = pairListSeperate2.get(i).replaceAll(&quot;user_story&quot;, &quot;us&quot;); // first column
		}
		for (int i = 0; i &lt; size; i++) {
			for (int j = 0; j &lt; size; j++) {
				String pair1 = pairListSeperate2.get(i);
				String pair2 = pairListSeperate2.get(j);
				int maximal = getTotalRedundanciesFromPair(redundantPairs2, pair1, pair2);
				table[i + 1][j + 1] = String.valueOf(maximal);
			}

		}
		return table;
	}

	private int getTotalRedundanciesFromPair(List&lt;ConflictPair&gt; redundantPairs, String pair1, String pair2) {
		for (ConflictPair redundantPair : redundantPairs) {
<span class="nc" id="L825">			if ((redundantPair.getRedundantPair1().equals(pair1) &amp;&amp; redundantPair.getRedundantPair2().equals(pair2))</span>
					|| (redundantPair.getRedundantPair1().equals(pair2)
							&amp;&amp; redundantPair.getRedundantPair2().equals(pair1))) {
				return redundantPair.getMaximal();
			}
		}

		return 0;
	}

	// check if critical pair list already contain of
	// whether user_story_XX_AND_user_story_YY
	// or user_story_YY_AND_user_story_XX, if yes return true,
	// Otherwise return false
<span class="nc" id="L839">	private boolean checkIfReportExist(String usPairs, List&lt;String&gt; pairList) {</span>
		if (!pairList.contains(usPairs)) {
			String us1 = getUsName1(usPairs);
			String us2 = getUsName2(usPairs);
			pairList.add(usPairs);
			// Add also reverse item
			pairList.add(us2 + &quot;_AND_&quot; + us1);

			return false;
		} else {

			return true;
		}
	}

<span class="nc" id="L854">	private boolean hasTargets(ArrayList&lt;String&gt; arrayMaximalElementsNames, ConflictItems redundancyItems) {</span>
		for (String item : arrayMaximalElementsNames) {
			for (Targets target : redundancyItems.getTargets()) {
				if (item.equals(target.getName())) {
					return true;
				}
			}
		}
		return false;
	}

	private boolean hasActions(ArrayList&lt;String&gt; arrayMaximalElementsNames, ConflictItems redundancyItems) {
		for (String item : arrayMaximalElementsNames) {
<span class="nc" id="L867">			for (SecondaryAction secondaryAction : redundancyItems.getSecondaryAction()) {</span>
				if (item.equals(secondaryAction.getName())) {
					return true;
				}
			}
			for (PrimaryAction primaryAction : redundancyItems.getPrimaryActions()) {
				if (item.equals(primaryAction.getName())) {
					return true;
				}
			}
		}
		return false;
	}

	private boolean hasEntitys(ArrayList&lt;String&gt; arrayMaximalElementsNames, ConflictItems redundancyItems) {
		for (String item : arrayMaximalElementsNames) {
<span class="nc" id="L883">			for (SecondaryEntity secondaryEntity : redundancyItems.getSecondaryEntity()) {</span>
				if (item.equals(secondaryEntity.getName())) {
					return true;
				}
			}
			for (Entity primaryEntity : redundancyItems.getPrimaryEntity()) {
				if (item.equals(primaryEntity.getName())) {
					return true;
				}
			}
		}

		return false;
	}

	// get USs Text from JSON File and add them into redundancyItems
	private void getUssTexts(String usPair, ConflictItems redundancyItems)
<span class="nc" id="L900">			throws JsonFileNotFound, IOException, EmptyOrNotExistJsonFile {</span>
		JSONArray json = null;
		String us1 = getUsName1(usPair);
		String us2 = getUsName2(usPair);

		json = readJsonArrayFromFile(getAbsoluteFinalReportDir());
		for (int i = 0; i &lt; json.length(); i++) {
			JSONObject jsonObject = json.getJSONObject(i);

			// check if two related object are exist in JSON file
			// if so

			String usNr = jsonObject.getString(&quot;US_Nr&quot;);
			// all words should be lower case to avoid mismatching
			String usText = jsonObject.getString(&quot;Text&quot;).toLowerCase();
			if (usNr.equals(us1)) {
				redundancyItems.setTextUs1(usText);

			} else if (usNr.equals(us2)) {

				redundancyItems.setTextUs2(usText);

			}

		}

	}

	private void writeUsText(String usPair, ArrayList&lt;String&gt; arrayMax, List&lt;ConflictPair&gt; redundantPairs,
			ConflictItems redundancyItems, FileWriter fileWriter, List&lt;TargetsPair&gt; targetsPairs,
			List&lt;TriggersPair&gt; triggersPairs, List&lt;ContainsPair&gt; containsPairs, JSONObject jsonRedundancyPair)
<span class="nc" id="L931">			throws IOException, EmptyOrNotExistJsonFile, JsonFileNotFound {</span>
		String us1 = getUsName1(usPair);
		String us2 = getUsName2(usPair);

		// add conflict pairs with maximal overlapping and save it
		// in order to filling table
		ConflictPair redundantPair = new ConflictPair();

		// here i try to add US_Nr from USs into the highlightConflicts
		redundancyItems.setUsNr1(us1);
		redundancyItems.setUsNr2(us2);

		// get USs Text from JSON File and add them into redundancyItems
		getUssTexts(usPair, redundancyItems);
		
			// here I want to send both USs as parameter for highlightingConflicts
			redundancyItems = highlightRedundancies(redundancyItems, usPair, targetsPairs, triggersPairs, containsPairs,
					jsonRedundancyPair);

			String highlightedUs2 = redundancyItems.getTextUs2();
			fileWriter.write(&quot;\n\n &quot; + us2 + &quot;: &quot; + highlightedUs2.toLowerCase());

			String highlightedUs1 = redundancyItems.getTextUs1();
			fileWriter.write(&quot;\n\n &quot; + us1 + &quot;: &quot; + highlightedUs1.toLowerCase());
			redundantPair.setRedundantPair1(us1);
			redundantPair.setRedundantPair2(us2);
			redundantPair.setMaximal(redundancyItems.getTotalRedundancyCount());
			redundantPairs.add(redundantPair);


	}

	// Separate user story &quot;Text&quot; with comma and then find in each area related
	// element.
	// For example if we are in second region (which means it need to looking for
	// primary
	// action/entity) after finding it check if the element contains in Targets, if
	// so,
	// add hash symbol(#) at the beginning and ending of the words.
	// For secondary action entity we looking ad the third region of sentence.
	// I want to check both user stories and separate their parts of sentence
	// through comma and first try to find the match is in secondPartOfSentence of
	// both user
	// stories. I should check US1_Part_1 vs US2_part_1, then if US1_Part_2 &amp;&amp;
	// US2_Part_2
	// are exist then try to file the match is in thirdPartOfSentence of both USs
	// then try
	// to replace
	private ConflictItems highlightRedundancies(ConflictItems redundancyItems, String usPair,
			List&lt;TargetsPair&gt; targetsPairs, List&lt;TriggersPair&gt; triggersPairs, List&lt;ContainsPair&gt; containsPairs,
<span class="nc" id="L981">			JSONObject jsonRedundancyPair) throws IOException, EmptyOrNotExistJsonFile, JsonFileNotFound {</span>

		String textUs1 = redundancyItems.getTextUs1();
		String textUs2 = redundancyItems.getTextUs2();
		int mainConflict = redundancyItems.getMainRedundancyCount();
		int benefitConflict = redundancyItems.getBenefitRedundancyCount();
		//if (textUs1.length() &lt;= 0 &amp;&amp; textUs2.length() &lt;= 0) {
	//		return null;
	//	}

		// find the index of first comma
		int firstCommaUs1 = textUs1.indexOf(',');
		int firstCommaUs2 = textUs2.indexOf(',');
		// if there is no main part in the sentence
		// which include triggers and targets
//		if (firstCommaUs1 == -1 || firstCommaUs2 == -1) {
//			return redundancyItems;
		// receive the index of first comma in both Text in USs
		// subString will be like this: I want to be able to ....
//		}
		String subStringFirstUs1 = textUs1.substring(0, firstCommaUs1);
		String subStringFirstUs2 = textUs2.substring(0, firstCommaUs2);

		// receive the index of second comma
		int benefitPlaceHolderUs1 = textUs1.indexOf(&quot;so that&quot;, firstCommaUs1 + 1);
		int benefitPlaceHolderUs2 = textUs2.indexOf(&quot;so that&quot;, firstCommaUs2 + 1);

		// if one of USs does't have benefit, then there is no conflicted
		// element at benefit at all just return benefit as it is
		// if US_1 does't have benefit
		if (benefitPlaceHolderUs1 == -1 &amp;&amp; benefitPlaceHolderUs2 != -1) {

			String subStringSecondUs1 = textUs1.substring(firstCommaUs1 + 1);
			String subStringSecondUs2 = textUs2.substring(firstCommaUs2 + 1, benefitPlaceHolderUs2);

			// I want to check if targetsPair.aciton/entity are already exist
			// in this main part, if so then add hash symbol
			String[] usText = applyHashSymbolTargetsMain(targetsPairs, containsPairs, redundancyItems,
					subStringSecondUs1, subStringSecondUs2, jsonRedundancyPair);
			textUs1 = subStringFirstUs1 + &quot;,&quot; + usText[0];
			textUs2 = subStringFirstUs2 + &quot;,&quot; + usText[1];
			// add the number of conflict pairs from main sentence
			mainConflict = mainConflict + Integer.parseInt(usText[2]);

			// subString from second comma until the end of story ;)
			String subStringBenefitUs2 = redundancyItems.getTextUs2().substring(benefitPlaceHolderUs2);

			// check if there are hash symbol more than 3 pair first and main section
			// if so then highlight the Persona
			if (hasMoreThanSixHashSymbols(textUs1)) {
				usText = applyHashSymbolPersona(triggersPairs, redundancyItems, textUs1, textUs2);
				textUs1 = usText[0];
				textUs2 = usText[1];
				// add the number of conflict pairs from main sentence
				mainConflict = mainConflict + Integer.parseInt(usText[2]);
			}
			// Apply hash symbol to common element in the both user stories if any
			usText = applyHashSymbolContaiansMain(containsPairs, redundancyItems, textUs1, textUs2, jsonRedundancyPair);
			textUs1 = usText[0];
			textUs2 = usText[1];
			// add the number of conflict pairs from main sentence
			mainConflict = mainConflict + Integer.parseInt(usText[2]);
			// I want to check if targetsPair.aciton/entity are already exist
			// in this sentence part, if so then add hash symbol
			textUs2 = textUs2 + subStringBenefitUs2;

		}
		// if US_2 does't have benefit
		if (benefitPlaceHolderUs1 != -1 &amp;&amp; benefitPlaceHolderUs2 == -1) {

			String subStringSecondUs1 = textUs1.substring(firstCommaUs1 + 1, benefitPlaceHolderUs1);
			String subStringSecondUs2 = textUs2.substring(firstCommaUs2 + 1);

			// I want to check if targetsPair.aciton/entity are already exist
			// in this sentence part, if so then add hash symbol
			String[] usText = applyHashSymbolTargetsMain(targetsPairs, containsPairs, redundancyItems,
					subStringSecondUs1, subStringSecondUs2, jsonRedundancyPair);
			textUs1 = subStringFirstUs1 + &quot;,&quot; + usText[0];
			textUs2 = subStringFirstUs2 + &quot;,&quot; + usText[1];
			// add the number of conflict pairs from main sentence
			mainConflict = mainConflict + Integer.parseInt(usText[2]);

			// subString from second comma until the end of story ;)
			String subStringBenefitUs1 = redundancyItems.getTextUs1().substring(benefitPlaceHolderUs1);

			// check if there are hash symbol more than 3 pair first and main section
			// if so then highlight the Persona
			if (hasMoreThanSixHashSymbols(textUs1)) {
				usText = applyHashSymbolPersona(triggersPairs, redundancyItems, textUs1, textUs2);
				textUs1 = usText[0];
				textUs2 = usText[1];
				// add the number of conflict pairs from main sentence
				mainConflict = mainConflict + Integer.parseInt(usText[2]);

			}

			// Apply hash symbol to common element in the both user stories if any
			usText = applyHashSymbolContaiansMain(containsPairs, redundancyItems, textUs1, textUs2, jsonRedundancyPair);
			textUs1 = usText[0];
			textUs2 = usText[1];
			// add the number of conflict pairs from main sentence
			mainConflict = mainConflict + Integer.parseInt(usText[2]);

			// I want to check if targetsPair.aciton/entity are already exist
			// in this sentence part, if so then add hash symbol
			textUs1 = textUs1 + subStringBenefitUs1;

		}
		// if both does't have benefit
		if (benefitPlaceHolderUs1 == -1 &amp;&amp; benefitPlaceHolderUs2 == -1) {
			String subStringSecondUs1 = textUs1.substring(firstCommaUs1 + 1);
			String subStringSecondUs2 = textUs2.substring(firstCommaUs2 + 1);

			// I want to check if targetsPair.aciton/entity are already exist
			// in this sentence part, if so then add hash symbol
			String[] usText = applyHashSymbolTargetsMain(targetsPairs, containsPairs, redundancyItems,
					subStringSecondUs1, subStringSecondUs2, jsonRedundancyPair);
			textUs1 = subStringFirstUs1 + &quot;,&quot; + usText[0];
			textUs2 = subStringFirstUs2 + &quot;,&quot; + usText[1];
			// add the number of conflict pairs from main sentence
			mainConflict = mainConflict + Integer.parseInt(usText[2]);

			// check if there are hash symbol more than 3 pair first and main section
			// if so then highlight the Persona
			if (hasMoreThanSixHashSymbols(textUs1)) {
				usText = applyHashSymbolPersona(triggersPairs, redundancyItems, textUs1, textUs2);
				textUs1 = usText[0];
				textUs2 = usText[1];
				// add the number of conflict pairs from main sentence
				mainConflict = mainConflict + Integer.parseInt(usText[2]);
			}

			// subString from second comma until the end of story ;)
			// I want to check if targetsPair.aciton/entity are already exist
			// in this sentence part, if so then add hash symbol

			// Apply hash symbol to common elements in the both user stories if any
			usText = applyHashSymbolContaiansMain(containsPairs, redundancyItems, textUs1, textUs2, jsonRedundancyPair);
			textUs1 = usText[0];
			textUs2 = usText[1];
			// add the number of conflict pairs from main sentence
			mainConflict = mainConflict + Integer.parseInt(usText[2]);

		}
		// if both USs have benefit
		if (benefitPlaceHolderUs1 != -1 &amp;&amp; benefitPlaceHolderUs2 != -1) {
			String subStringSecondUs1 = textUs1.substring(firstCommaUs1 + 1, benefitPlaceHolderUs1);
			String subStringSecondUs2 = textUs2.substring(firstCommaUs2 + 1, benefitPlaceHolderUs2);
			// I want to check if targetsPair.aciton/entity are already exist
			// in this sentence part, if so then add hash symbol
			// first try to find conflict pairs at the main sentence
			String[] usText = applyHashSymbolTargetsMain(targetsPairs, containsPairs, redundancyItems,
					subStringSecondUs1, subStringSecondUs2, jsonRedundancyPair);

			textUs1 = usText[0];
			textUs2 = usText[1];
			// add the number of conflict pairs from main sentence
			mainConflict = mainConflict + Integer.parseInt(usText[2]);

			// check if there are hash symbol more than 3 pair first and main section
			// if so then highlight the Persona
			if (hasMoreThanFourHashSymbols(textUs1)) {
				usText = applyHashSymbolPersona(triggersPairs, redundancyItems, subStringFirstUs1, subStringFirstUs2);
				subStringFirstUs1 = usText[0];
				subStringFirstUs2 = usText[1];
				// add the number of conflict pairs from main sentence
				mainConflict = mainConflict + Integer.parseInt(usText[2]);
			}

			// Apply hash symbol to common elements in Main from the both user stories if
			// any
			usText = applyHashSymbolContaiansMain(containsPairs, redundancyItems, textUs1, textUs2, jsonRedundancyPair);
			textUs1 = usText[0];
			textUs2 = usText[1];
			// add the number of conflict pairs from main sentence
			mainConflict = mainConflict + Integer.parseInt(usText[2]);

			// subString from second comma until the end of story ;)
			String subStringBenefitUs1 = redundancyItems.getTextUs1().substring(benefitPlaceHolderUs1);
			String subStringBenefitUs2 = redundancyItems.getTextUs2().substring(benefitPlaceHolderUs2);

			// I want to check if targetsPair.aciton/entity are already exist
			// in this benefit part, if so then add hash symbol
			// first try to find conflict pairs at the benefit sentence
			usText = applyHashSymbolTargetsBenefit(targetsPairs, containsPairs, redundancyItems, subStringBenefitUs1,
					subStringBenefitUs2, jsonRedundancyPair);
			subStringBenefitUs1 = usText[0];
			subStringBenefitUs2 = usText[1];

			// add the number of conflict pairs from benefit sentence
			benefitConflict = benefitConflict + Integer.parseInt(usText[2]);

			// Apply hash symbol to common elements in Benefit part of the both user stories
			// if any
			usText = applyHashSymbolContaiansBenefit(containsPairs, redundancyItems, subStringBenefitUs1,
					subStringBenefitUs2, jsonRedundancyPair);
			subStringBenefitUs1 = usText[0];
			subStringBenefitUs2 = usText[1];
			// add the number of conflict pairs from main sentence
			benefitConflict = benefitConflict + Integer.parseInt(usText[2]);

			// concatenate main part and benefit parts
			textUs1 = textUs1 + subStringBenefitUs1;
			textUs2 = textUs2 + subStringBenefitUs2;

			// if contains elements are distributed in both parts
			// (one element in main and on in benefit), it the conflict element of main
			// should be increased not main and benefit
			// Apply hash symbol to common elements in the both user stories if any
			textUs1 = subStringFirstUs1 + &quot;,&quot; + textUs1;
			textUs2 = subStringFirstUs2 + &quot;,&quot; + textUs2;

		}

		// add amount of founded conflict pairs from main/benefit sentence
		// into Benefit/MainConflict Count
		redundancyItems.setBenefitRedundancyCount(benefitConflict);
		redundancyItems.setMainRedundancyCount(mainConflict);
		redundancyItems.setMaxRedundancyCount(mainConflict + benefitConflict);
		redundancyItems.setTextUs1(textUs1);
		redundancyItems.setTextUs2(textUs2);

		return redundancyItems;

	}

<span class="nc" id="L1207">	private String[] applyHashSymbolContaiansMain(List&lt;ContainsPair&gt; containsPairs, ConflictItems redundancyItems,</span>
			String subStringUs1, String subStringUs2, JSONObject jsonRedundancyPair) {
		String[] usTexts = new String[4];
		int redundancyCount = 0;
		JSONArray jsonContains = new JSONArray();
		// iterate through commonContains and check other element of pair related to
		// the containsPair if any exist but filter: [containsPair,contain] case
		// which is the same pair in which is already parsed
		for (ContainsPair containsPair2 : containsPairs) {
			String child = containsPair2.getChildEntity();
			String parent = containsPair2.getParentEntity();
			// check if both elements of contains is included in both segment part
			// and check do so if
			if ((subStringUs1.contains(child) &amp;&amp; subStringUs2.contains(child) &amp;&amp; subStringUs1.contains(parent)
					&amp;&amp; subStringUs2.contains(parent))) {

				// add hash symbol to contains pairs
				String[] matches = { parent, child };
				subStringUs1 = applyHashSymbols(subStringUs1, matches);
				subStringUs2 = applyHashSymbols(subStringUs2, matches);

				redundancyCount++;
				// break in order to avoid of counting redundant items
				// add to JOSN report as Common Contains in Main
				JSONArray jsonContain = new JSONArray().put(parent).put(child);
				jsonContains.put(jsonContain);
			}
		}
		JSONObject jsonCommonContains = new JSONObject();
		jsonCommonContains.put(&quot;Main Part&quot;, jsonContains);
		jsonRedundancyPair.put(&quot;Common Contains&quot;, jsonCommonContains);
		usTexts[0] = subStringUs1.replaceAll(&quot;#+&quot;, &quot;#&quot;);
		usTexts[1] = subStringUs2.replaceAll(&quot;#+&quot;, &quot;#&quot;);
		usTexts[2] = String.valueOf(redundancyCount);
		return usTexts;
	}

<span class="nc" id="L1244">	private String[] applyHashSymbolTargetsMain(List&lt;TargetsPair&gt; targetsPairs, List&lt;ContainsPair&gt; containsPairs,</span>
			ConflictItems redundancyItems, String subStringUs1, String subStringUs2, JSONObject jsonRedundancyPair) {
		String[] usTexts = new String[4];
		int redundancyCount = 0;
		JSONArray jsonTargets = new JSONArray();
		// I want to check if targetsPair.aciton/entity are already exist
		// in this sentence part, if so then add hash symbol
		for (TargetsPair targetsPair : targetsPairs) {
			// replace all pairs in this part of sentence if it
			// exist in both sentence parts
			String action = targetsPair.getAction();
			String entity = targetsPair.getEntity();
			if ((subStringUs1.contains(action) &amp;&amp; subStringUs1.contains(entity))
					&amp;&amp; (subStringUs2.contains(action) &amp;&amp; subStringUs2.contains(entity))) {
				// US_1 add hash symbol at the beginning and ending of each word
				String[] actionMatches = { action };
				String[] entityMatches = { entity };
				subStringUs1 = applyHashSymbols(subStringUs1, actionMatches);
				subStringUs1 = applyHashSymbols(subStringUs1, entityMatches);

				// US_2 add hash symbol at the beginning and ending of each word
				subStringUs2 = applyHashSymbols(subStringUs2, actionMatches);
				subStringUs2 = applyHashSymbols(subStringUs2, entityMatches);

				// count conflicts in this sentence part in order to know which sentence
				// part how many conflict pairs exist
				redundancyCount++;
				// check if entity exist in contains list

				// add to JOSN report as Common Targets in Main
				JSONArray josnTarget = new JSONArray().put(action).put(entity);
				jsonTargets.put(josnTarget);
			}
		}
		JSONObject jsonCommonTargets = jsonRedundancyPair.optJSONObject(&quot;Common Targets&quot;);
		if (jsonCommonTargets == null) {
			jsonCommonTargets = new JSONObject();
			jsonCommonTargets.put(&quot;Main Part&quot;, jsonTargets);
			jsonRedundancyPair.put(&quot;Common Targets&quot;, jsonCommonTargets);
		}
		jsonCommonTargets.put(&quot;Main Part&quot;, jsonTargets);

		usTexts[0] = subStringUs1.replaceAll(&quot;#+&quot;, &quot;#&quot;);
		usTexts[1] = subStringUs2.replaceAll(&quot;#+&quot;, &quot;#&quot;);
		usTexts[2] = String.valueOf(redundancyCount);
		return usTexts;
	}

<span class="nc" id="L1292">	private String[] applyHashSymbolTargetsBenefit(List&lt;TargetsPair&gt; targetsPairs, List&lt;ContainsPair&gt; containsPairs,</span>
			ConflictItems redundancyItems, String subStringUs1, String subStringUs2, JSONObject jsonRedundancyPair) {
		String[] usTexts = new String[4];
		int redundancyCount = 0;
		JSONArray jsonTargets = new JSONArray();
		// I want to check if targetsPair.aciton/entity are already exist
		// in this sentence part, if so then add hash symbol
		for (TargetsPair targetsPair : targetsPairs) {
			// replace all pairs in this part of sentence if it
			// exist in both sentence parts
			String action = targetsPair.getAction();
			String entity = targetsPair.getEntity();
			if ((subStringUs1.contains(action) &amp;&amp; subStringUs1.contains(entity))
					&amp;&amp; (subStringUs2.contains(action) &amp;&amp; subStringUs2.contains(entity))) {
				// US_1 add hash symbol at the beginning and ending of each word
				String[] actionMatches = { action };
				String[] entityMatches = { entity };
				subStringUs1 = applyHashSymbols(subStringUs1, actionMatches);
				subStringUs1 = applyHashSymbols(subStringUs1, entityMatches);

				// US_2 add hash symbol at the beginning and ending of each word
				subStringUs2 = applyHashSymbols(subStringUs2, actionMatches);
				subStringUs2 = applyHashSymbols(subStringUs2, entityMatches);

				// count conflicts in this sentence part in order to know which sentence
				// part how many conflict pairs exist
				redundancyCount++;

				// check if entity exist in contains list
				// add to JOSN report as Common Targets in Benefit
				JSONArray josnTarget = new JSONArray().put(action).put(entity);
				jsonTargets.put(josnTarget);
			}
		}

		// JSONObject jsonCommonTargets = new JSONObject();
		JSONObject jsonCommonTargets = jsonRedundancyPair.optJSONObject(&quot;Common Targets&quot;);
		if (jsonCommonTargets == null) {
			jsonCommonTargets = new JSONObject();
			jsonRedundancyPair.put(&quot;Common Targets&quot;, jsonCommonTargets);
		}
		jsonCommonTargets.put(&quot;Benefit Part&quot;, jsonTargets);
		usTexts[0] = subStringUs1.replaceAll(&quot;#+&quot;, &quot;#&quot;);
		usTexts[1] = subStringUs2.replaceAll(&quot;#+&quot;, &quot;#&quot;);
		usTexts[2] = String.valueOf(redundancyCount);
		return usTexts;
	}

<span class="nc" id="L1340">	private boolean hasMoreThanFourHashSymbols(String textUs1) {</span>
		long count = textUs1.chars().filter(ch -&gt; ch == '#').count();
		return count &gt;= 4;

	}

<span class="nc" id="L1346">	private String[] applyHashSymbolPersona(List&lt;TriggersPair&gt; triggers, ConflictItems redundancyItems,</span>
			String subStringFirstUs1, String subStringFirstUs2) {
		String[] usTexts = new String[4];
		int redundancyCount = 0;

		// I want to check if TriggersPair persona/action are already exist
		// in this sentence part, if so then add hash symbol
		// Add if and only if the action in triggers pair are exist in
		// *.redundanted targets pairs
		for (TriggersPair triggerPair : triggers) {
			String persona = triggerPair.getPersona();
			// replace all pairs in this part of sentence if it
			// exist in both sentence parts
			if (subStringFirstUs1.contains(persona) &amp;&amp; subStringFirstUs2.contains(persona)) {

				// US_1/US_2 add hash symbol at the beginning and ending of each word
				String[] matches = { persona };
				subStringFirstUs1 = applyHashSymbols(subStringFirstUs1, matches);
				subStringFirstUs2 = applyHashSymbols(subStringFirstUs2, matches);

				// count conflicts in this sentence part in order to know which sentence
				// part how many conflict pairs exist
				// after highlighting persona it should be check if
				// to pairs of triggers elements exist, then increase the count
				// of elements if and only if the action is also in targets

				redundancyCount++;

			}

		}
		usTexts[0] = subStringFirstUs1.replaceAll(&quot;#+&quot;, &quot;#&quot;);
		usTexts[1] = subStringFirstUs2.replaceAll(&quot;#+&quot;, &quot;#&quot;);
		usTexts[2] = String.valueOf(redundancyCount);
		return usTexts;
	}

	// replace hash symbol at beginning and ending of founded element
<span class="nc" id="L1384">	private String applyHashSymbols(String subString, String[] matches) {</span>
		Arrays.sort(matches, Comparator.comparing(String::length).reversed());
		for (String match : matches) {
			subString = subString.replaceAll(&quot;\\b&quot; + match + &quot;\\b&quot;, &quot;#&quot; + match + &quot;#&quot;);
		}
		return subString;
	}

	// Check in the main part of sentence if there is any redundancy
	// more than 6 hash mark exist
<span class="nc" id="L1394">	private boolean hasMoreThanSixHashSymbols(String textUs1) {</span>
		long count = textUs1.chars().filter(ch -&gt; ch == '#').count();
		return count &gt;= 6;
	}

<span class="nc" id="L1399">	private String[] applyHashSymbolContaiansBenefit(List&lt;ContainsPair&gt; containsPairs, ConflictItems redundancyItems,</span>
			String subStringUs1, String subStringUs2, JSONObject jsonRedundancyPair) {
		String[] usTexts = new String[4];
		int redundancyCount = 0;
		JSONArray jsonContains = new JSONArray();
		// iterate through commonContains and check other element of pair related to
		// the containsPair if any exist but filter: [containsPair,contain] case
		// which is the same pair in which is already parsed
		for (ContainsPair containsPair2 : containsPairs) {
			String child = containsPair2.getChildEntity();
			String parent = containsPair2.getParentEntity();
			// check if both elements of contains is included in both segment part
			// and check do so if
			if ((subStringUs1.contains(child) &amp;&amp; subStringUs2.contains(child) &amp;&amp; subStringUs1.contains(parent)
					&amp;&amp; subStringUs2.contains(parent))
			// &amp;&amp; !(subStringUs1.contains(&quot;#&quot; + child + &quot;#&quot;)
//							&amp;&amp; subStringUs2.contains(&quot;#&quot; + child + &quot;#&quot;)
//							&amp;&amp; subStringUs1.contains(&quot;#&quot; + parent + &quot;#&quot;)
//							&amp;&amp; subStringUs2.contains(&quot;#&quot; + parent + &quot;#&quot;)
			) {

				// add hash symbol to contains pairs
				String[] matches = { parent, child };
				subStringUs1 = applyHashSymbols(subStringUs1, matches);
				subStringUs2 = applyHashSymbols(subStringUs2, matches);

				redundancyCount++;
				// break in order to avoid of counting redundant items
				// add to JOSN report as Common Contains in Benefit
				JSONArray jsonContain = new JSONArray().put(parent).put(child);
				jsonContains.put(jsonContain);
			}
		}

		JSONObject jsonCommonContains = jsonRedundancyPair.optJSONObject(&quot;Common Contains&quot;);
		if (jsonCommonContains == null) {
			jsonCommonContains = new JSONObject();
			jsonRedundancyPair.put(&quot;Common Contains&quot;, jsonCommonContains);
		}
		jsonCommonContains.put(&quot;Benefit Part&quot;, jsonContains);

		usTexts[0] = subStringUs1.replaceAll(&quot;#+&quot;, &quot;#&quot;);
		usTexts[1] = subStringUs2.replaceAll(&quot;#+&quot;, &quot;#&quot;);
		usTexts[2] = String.valueOf(redundancyCount);
		return usTexts;

	}

	private void iteratePackages(EPackage minimalPackage, ArrayList&lt;String&gt; arrayMaximalElements,
			ArrayList&lt;String&gt; arrayMaximalElementsNames, ConflictItems redundancyItems) throws IOException {

		String className = null;

		for (EClassifier eClassifier : minimalPackage.getEClassifiers()) {
			if (eClassifier instanceof EClass) {
				EClass eClass = (EClass) eClassifier;
				className = getClassName(eClass.getName());

				// if there is conflict between Attributes of tow USs, the hash symbol will
				// appear on the class-Name and not directly on attribute,
				// so we try to verify class name and check if it contains any hash symbol?
				if (eClass.getName().contains(&quot;#&quot;)) {

					EAttribute attribute = (EAttribute) eClass.getEStructuralFeature(0);
					if (attribute != null &amp;&amp; !arrayMaximalElements.contains(attribute.getName())) {

						String attName = getAttName(attribute.getName());

						arrayMaximalElements.add(attribute.getName());
						arrayMaximalElementsNames.add(attName);

						// store conflicted Attributes according to their class
						switch (className) {
						case &quot;Primary Action&quot;:
<span class="nc" id="L1473">							redundancyItems.addPrimaryAction(new PrimaryAction(attName));</span>
							break;
						case &quot;Secondary Action&quot;:
							redundancyItems.addSecondaryAction(new SecondaryAction(attName));
							break;
						case &quot;Secondary Entity&quot;:
							redundancyItems.addSecondaryEntity(new SecondaryEntity(attName));
							break;
						case &quot;Primary Entity&quot;:
							redundancyItems.addPrimaryEntity(new Entity(attName));
							break;
						default:
							break;
						}

					}
				}
				// add all EReferences from EClass into corresponding
				// type(Contains, Targets, Triggers)
				for (EReference eReference : eClass.getEReferences()) {
					if (eReference.getName().contains(&quot;#&quot;) &amp;&amp; !arrayMaximalElements.contains(eReference.getName())) {

						String refName = getRefName(eReference.getName());
						arrayMaximalElements.add(eReference.getName());
						arrayMaximalElementsNames.add(refName);

						if (refName.equals(&quot;triggers&quot;)) {

							redundancyItems.addTriggers(new Triggers(refName, className));

						} else if (refName.equals(&quot;targets&quot;)) {

							redundancyItems.addTargets(new Targets(refName, className));

						} else if (refName.equals(&quot;contains&quot;)) {
							redundancyItems.addContains(new Contains(refName, className));

						}

					}

				}
			}

		}

	}

<span class="nc" id="L1521">	private String getRefName(String name) {</span>
		name = name.replaceAll(&quot;#&quot;, &quot;&quot;);
		return name;
	}

<span class="nc" id="L1526">	private String getClassName(String name) {</span>
		name = name.replaceAll(&quot;#&quot;, &quot;&quot;).replaceAll(&quot;.*:(.*)&quot;, &quot;$1&quot;);
		return name;
	}

<span class="nc" id="L1531">	private String getAttName(String name) {</span>
		name = name.replaceAll(&quot;name=\&quot;(.*)\&quot;-&gt;.*\&quot;(.*).*&quot;, &quot;$1&quot;);
		return name;
	}

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span>JSONTransformerTest (04.07.2024 14:34:06)</div></body></html>